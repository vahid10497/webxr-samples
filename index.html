<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>

    <title>Immersive AR Session</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>Immersive AR Session</summary>
        <p>
          This sample demonstrates how to use an 'immersive-ar' XRSession to
          present a simple WebGL scene to a transparent or passthrough XR
          device. The logic is largely the same as the corresponding VR sample,
          with the primary difference being that no background is rendered and
          the model is scaled down for easier viewing in a real-world space.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {SkyboxNode} from './js/render/nodes/skybox.js';
      import {InlineViewerHelper} from './js/util/inline-viewer-helper.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {QueryArgs} from './js/util/query-args.js';

      import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
      if (QueryArgs.getBool('usePolyfill', true)) {
        let polyfill = new WebXRPolyfill();
      }

      let xrButton = null;
      let xrImmersiveRefSpace = null;
      let inlineViewerHelper = null;

      let gl = null;
      let renderer = null;
      let scene = new Scene();
      let solarSystem = new Gltf2Node({url: 'media/gltf/space/space.gltf'});
solarSystem.scale = [0.1, 0.1, 0.1];
      let skybox = new SkyboxNode({url: 'media/textures/milky-way-4k.png'});
      scene.addNode(skybox);

      // --- Geolocation target offset ---
      const targetLat = 48.28995554409128;
      const targetLon = 14.282849641415106;
      let userLatLon = null;

function gpsToOffset(user, target) {
  const R = 6371000;
  const dLat = (target.lat - user.lat) * Math.PI / 180;
  const dLon = (target.lon - user.lon) * Math.PI / 180;
  const lat1 = user.lat * Math.PI / 180;
  const lat2 = target.lat * Math.PI / 180;

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;

  const bearing = Math.atan2(
    Math.sin(dLon) * Math.cos(lat2),
    Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)
  );

  return {
    x: distance * Math.sin(bearing),
    z: distance * Math.cos(bearing)
  };
}

      function updateStatus(msg) {
        const el = document.getElementById('status');
        if (el) el.innerText = msg;
      }

      function getLocation() {
        updateStatus('Getting GPS location...');
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
  userLatLon = {
    lat: pos.coords.latitude,
    lon: pos.coords.longitude
  };

  const offset = gpsToOffset(userLatLon, { lat: targetLat, lon: targetLon });
  solarSystem.translation = [offset.x, 2, offset.z];
  solarSystem._readyToAdd = true;

  console.log(`‚úÖ GPS working.
üìç lat: ${userLatLon.lat.toFixed(6)}
üìç lon: ${userLatLon.lon.toFixed(6)}
‚úÖ Object placed via GPS`);
          }, err => {
            updateStatus('‚ùå GPS error: ' + err.message);
          }, { enableHighAccuracy: true });
        } else {
          updateStatus('‚ùå Geolocation not supported');
        }
      }

      function initXR() {
        getLocation();
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT  AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
          });

          navigator.xr.requestSession('inline').then(onSessionStarted);
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar', {
          
        })
            .then((session) => {
              xrButton.setSession(session);
              session.isImmersive = true;
              onSessionStarted(session);
            });
      }

      function initGL() {
        if (gl) return;

        gl = createWebGLContext({ xrCompatible: true });
        document.body.appendChild(gl.canvas);

        function onResize() {
          gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
          gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
        }
        window.addEventListener('resize', onResize);
        onResize();

        renderer = new Renderer(gl);
        scene.setRenderer(renderer);

        // Add solarSystem only after XR is ready
        if (solarSystem._readyToAdd) {
          scene.addNode(solarSystem);
        }
      }

      function onSessionStarted(session) {
  // Keeping header visible for testing
  
        session.addEventListener('end', onSessionEnded);

        if (session.isImmersive) {
          skybox.visible = false;
        }

        initGL();

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        let refSpaceType = session.isImmersive ? 'local' : 'viewer';
        session.requestReferenceSpace(refSpaceType).then((refSpace) => {
          if (session.isImmersive) {
            xrImmersiveRefSpace = refSpace;

            xrImmersiveRefSpace.addEventListener('reset', (evt) => {
              if (evt.transform) {
                xrImmersiveRefSpace = xrImmersiveRefSpace.getOffsetReferenceSpace(evt.transform);
              }
            });
          } else {
            inlineViewerHelper = new InlineViewerHelper(gl.canvas, refSpace);
          }
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        if (event.session.isImmersive) {
          xrButton.setSession(null);
          skybox.visible = true;
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let refSpace = session.isImmersive ? xrImmersiveRefSpace : inlineViewerHelper.referenceSpace;
        let pose = frame.getViewerPose(refSpace);

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
if (scene && scene.nodes) {
  if (solarSystem.translation) {
    const solarX = solarSystem.translation[0].toFixed(2);
    const solarY = solarSystem.translation[1].toFixed(2);
    const solarZ = solarSystem.translation[2].toFixed(2);
    console.log(`üì¶ SolarSystem position - X: ${solarX}, Y: ${solarY}, Z: ${solarZ}`);
  } else {
    console.log("‚è≥ SolarSystem translation not yet available");
  }
}
scene.endFrame();
      }

      initXR();

// Show status box only after AR starts

    </script>
    <div id="status" style="position: absolute; top: 10px; left: 10px; background: white; padding: 8px; font-family: sans-serif; font-size: 14px; z-index: 9999;">Initializing...</div>
</body>
</html>
