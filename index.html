<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>
    <title>Immersive AR Session</title>
  </head>
  <body>
    <header>
      <details open>
        <summary>Immersive AR Session</summary>
        <p>
          This sample demonstrates how to use an 'immersive-ar' XRSession to
          present a simple WebGL scene to a transparent or passthrough XR
          device. The logic is largely the same as the corresponding VR sample,
          with the primary difference being that no background is rendered and
          the model is scaled down for easier viewing in a real-world space.
          <a class="back" href="./">Back</a>
        </p>
      </details>
    </header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {SkyboxNode} from './js/render/nodes/skybox.js';
      import {InlineViewerHelper} from './js/util/inline-viewer-helper.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {QueryArgs} from './js/util/query-args.js';

      import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
      if (QueryArgs.getBool('usePolyfill', true)) {
        let polyfill = new WebXRPolyfill();
      }

      let xrButton = null;
      let xrImmersiveRefSpace = null;
      let inlineViewerHelper = null;

      let gl = null;
      let renderer = null;
      let scene = new Scene();
      let solarSystem = new Gltf2Node({url: 'media/gltf/space/space.gltf'});
      solarSystem.scale = [0.1, 0.1, 0.1];

      let skybox = new SkyboxNode({url: 'media/textures/milky-way-4k.png'});
      scene.addNode(skybox);

      function gpsToOffset(user, target) {
  const R = 6371000;
  const dLat = (target.lat - user.lat) * Math.PI / 180;
  const dLon = (target.lon - user.lon) * Math.PI / 180;
  const lat1 = user.lat * Math.PI / 180;
  const lat2 = target.lat * Math.PI / 180;

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const distance = R * c;

  const bearing = Math.atan2(
    Math.sin(dLon) * Math.cos(lat2),
    Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon)
  );

  return {
    x: distance * Math.sin(bearing),
    z: distance * Math.cos(bearing)
  };
}

function getLocation() {
  const targetLat = 48.28995554409128;
  const targetLon = 14.282849641415106;

  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(pos => {
      const userLatLon = {
        lat: pos.coords.latitude,
        lon: pos.coords.longitude
      };

      const offset = gpsToOffset(userLatLon, { lat: targetLat, lon: targetLon });
      // Wait for user orientation from onXRFrame
window.solarOffset = offset;

      if (renderer) {
        scene.addNode(solarSystem);
      }

      console.log(`‚úÖ GPS working.
üìç lat: ${userLatLon.lat.toFixed(6)}
üìç lon: ${userLatLon.lon.toFixed(6)}
üì¶ SolarSystem offset: X=${offset.x.toFixed(2)}m Z=${offset.z.toFixed(2)}m`);
    }, err => {
      console.warn('‚ùå GPS error: ' + err.message);
    }, { enableHighAccuracy: true });
  } else {
    console.warn('‚ùå Geolocation not supported');
  }
}

function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            xrButton.enabled = supported;
          });

          navigator.xr.requestSession('inline').then(onSessionStarted);
        }
      }

      function onRequestSession() {
        return navigator.xr.requestSession('immersive-ar')
            .then((session) => {
              xrButton.setSession(session);
              session.isImmersive = true;
              onSessionStarted(session);
            });
      }

      function initGL() {
        if (gl) return;

        gl = createWebGLContext({ xrCompatible: true });
        document.body.appendChild(gl.canvas);

        function onResize() {
          gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
          gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
        }
        window.addEventListener('resize', onResize);
        onResize();

        renderer = new Renderer(gl);
        scene.setRenderer(renderer);

        // GPS should be triggered only after renderer is ready
        getLocation();
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        if (session.isImmersive) {
          skybox.visible = false;
        }

        initGL();

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        let refSpaceType = session.isImmersive ? 'local' : 'viewer';
        session.requestReferenceSpace(refSpaceType).then((refSpace) => {
          if (session.isImmersive) {
            xrImmersiveRefSpace = refSpace;

            xrImmersiveRefSpace.addEventListener('reset', (evt) => {
              if (evt.transform) {
                xrImmersiveRefSpace = xrImmersiveRefSpace.getOffsetReferenceSpace(evt.transform);
              }
            });
          } else {
            inlineViewerHelper = new InlineViewerHelper(gl.canvas, refSpace);
          }

          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        if (event.session.isImmersive) {
          xrButton.setSession(null);
          skybox.visible = true;
        }
      }

      function onXRFrame(t, frame) {
        if (!window.gpsPlaced) window.gpsPlaced = false;
        if (!window.headingCaptured) window.headingCaptured = false;
        let session = frame.session;
        let refSpace = session.isImmersive ? xrImmersiveRefSpace : inlineViewerHelper.referenceSpace;
        let pose = frame.getViewerPose(refSpace);

        // Align model to GPS using user's facing direction
        if (!window.gpsPlaced && window.solarOffset && pose) {
          const orientation = pose.views[0].transform.orientation;
          const q = orientation;
          const heading = Math.atan2(2.0 * (q.x * q.z + q.w * q.y), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z);
          window.headingCaptured = true;

          const rotatedX = window.solarOffset.x * Math.cos(heading) - window.solarOffset.z * Math.sin(heading);
          const rotatedZ = window.solarOffset.x * Math.sin(heading) + window.solarOffset.z * Math.cos(heading);
          solarSystem.translation = [rotatedX, 2, rotatedZ];

          if (!scene.nodes.includes(solarSystem)) {
            scene.addNode(solarSystem);
          }

          console.log(`üìç Final model position: X=${rotatedX.toFixed(2)} Z=${rotatedZ.toFixed(2)}`);

          window.gpsPlaced = true;
          delete window.solarOffset;
        }
        }

        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      initXR();
    </script>
  </body>
</html>
